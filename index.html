<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>REVINGO ー Reversi × Bingo ー</title>
  <style>
    :root{color-scheme:dark;}
    html,body{height:100%;margin:0;background:#0b0f14;color:#e7eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    /* Layout: keep header slim and ensure canvas area is always tappable (including bottom row) */
    #wrap{height:100%;display:flex;flex-direction:column;min-height:0;}

    header{flex:0 0 auto;display:flex;flex-wrap:wrap;gap:6px;align-items:center;
      padding:6px 8px calc(6px + env(safe-area-inset-top));
      border-bottom:1px solid #1b2633;background:#0c121a;
    }

    .pill{padding:6px 10px;border:1px solid #223244;border-radius:999px;background:#0f1822;line-height:1.2;}
    .mini{padding:5px 9px;font-size:13px;}
    .title{font-weight:700;letter-spacing:.2px;}

    header select, header button{
      background:#0f1822;color:#e7eef7;border:1px solid #223244;border-radius:12px;
      padding:8px 10px;cursor:pointer;font-size:13px;
    }
    header button:hover{filter:brightness(1.07)}
    header button:active{transform:translateY(1px)}
    header button:disabled{opacity:.55;cursor:not-allowed}

    /* HUD grid: compact on mobile */
    #hud{display:grid;gap:6px;grid-template-columns:repeat(2,minmax(0,1fr));flex:1 1 320px;min-width:240px;}
    #hud .pill{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

    .controls{display:flex;gap:6px;flex-wrap:wrap;align-items:center;}
    .controls .pill{display:flex;gap:8px;align-items:center;}

    /* Main canvas region */
    #main{flex:1 1 auto;min-height:0;display:flex;flex-direction:column;}
    #canvasWrap{flex:1 1 auto;min-height:0;position:relative;}
    #canvas{display:block;width:100%;height:100%;touch-action:none;}

    /* Bottom bar (rule button) – does NOT overlay the board area */
    #bottomBar{flex:0 0 auto;padding:8px 10px calc(10px + env(safe-area-inset-bottom));
      background:linear-gradient(to top, rgba(12,18,26,0.92), rgba(12,18,26,0.72));
      border-top:1px solid #1b2633;
      display:flex;justify-content:center;align-items:center;
    }
    #rulesBtn{min-width:min(520px,92vw);}

    /* Toast */
    #toast{position:fixed;left:50%;transform:translateX(-50%);
      bottom:calc(64px + env(safe-area-inset-bottom));
      background:rgba(14,22,32,0.92);border:1px solid rgba(120,160,210,0.25);
      padding:10px 14px;border-radius:999px;backdrop-filter:blur(6px);
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      opacity:0;pointer-events:none;transition:opacity .18s ease;
      max-width:min(640px,92vw);text-align:center;
    }
    #toast.show{opacity:1;}

    /* Overlay modal */
    #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.55);backdrop-filter:blur(2px);padding:18px;
    }
    #overlay .card{background:#0c121a;border:1px solid #223244;border-radius:18px;
      padding:18px 16px;min-width:280px;max-width:min(520px,92vw);
      box-shadow:0 12px 30px rgba(0,0,0,0.45)
    }
    #overlay h2{margin:0 0 8px 0;font-size:18px}
    #overlay p{margin:6px 0;color:#b9c7d8;line-height:1.5}
    #overlay .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    #overlay button{flex:1}

    /* Rules drawer */
    #rules{position:fixed;left:0;right:0;bottom:0;transform:translateY(105%);
      transition:transform .22s ease;z-index:20;
      background:rgba(12,18,26,0.96);border-top:1px solid #223244;backdrop-filter:blur(8px);
      padding:14px 14px calc(14px + env(safe-area-inset-bottom));
      max-height:min(52vh,520px);overflow:auto;
    }
    #rules.show{transform:translateY(0%);}
    #rules .head{display:flex;justify-content:space-between;gap:10px;align-items:center;margin-bottom:8px;}
    #rules .warn{color:#ffd27a}
    kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;background:#101a24;border:1px solid #243447;border-bottom-width:2px;border-radius:6px;padding:1px 6px;color:#d7e6ff}

    @media (max-width: 420px){
      header{padding:6px 8px calc(6px + env(safe-area-inset-top));}
      .pill{padding:5px 8px;font-size:12px;}
      header select, header button{padding:7px 9px;font-size:12px}
    }
  </style>
</head>
<body>
<div id="wrap">
  <header>
    <span class="pill mini title" id="titlePill">REVINGO</span>

    <div id="hud">
      <span class="pill mini" id="turnPill">手番: -</span>
      <span class="pill mini" id="scorePill">得点 黒:0 / 白:0</span>
      <span class="pill mini" id="diffPill">スコア差(自分-敵): 0</span>
      <span class="pill mini" id="itemPill">⚡ 黒:1 / 白:1</span>
    </div>

    <div class="controls">
      <label class="pill mini" style="gap:8px;">
        対戦
        <select id="modeSel">
          <option value="cpu">人 vs CPU（白）</option>
          <option value="pvp">人 vs 人</option>
        </select>
      </label>

      <label class="pill mini" style="gap:8px;">
        テーマ
        <select id="themeSel">
          <option value="neon">ネオン</option>
          <option value="classic">クラシック</option>
        </select>
      </label>

      <button id="lightningBtn" class="mini" title="稲妻：双方合法手なしのときだけ使用可">⚡ 稲妻</button>
      <button id="resetBtn" class="mini">リセット</button>
    </div>
  </header>

  <div id="main">
    <div id="canvasWrap">
      <canvas id="canvas"></canvas>
    </div>

    <div id="bottomBar">
      <button id="rulesBtn" class="pill">ルールを見る</button>
    </div>
  </div>
</div>

<div id="toast"></div>

<div id="overlay">
  <div class="card">
    <h2 id="ovTitle">通知</h2>
    <p id="ovBody"></p>
    <div class="row" id="ovRow">
      <button id="ovPrimary">OK</button>
      <button id="ovSecondary" style="display:none">キャンセル</button>
    </div>
  </div>
</div>

<div id="rules">
  <div class="head">
    <div class="pill" style="border-radius:12px;">ルール</div>
    <button id="rulesClose">閉じる</button>
  </div>
  <div><span class="warn">REVINGO</span>：<b>Reversi × Bingo</b>（オセロの挟み＋ビンゴのライン成立）。盤面は <b>8×8固定</b>。</div>
  <div style="margin-top:6px;"><span class="warn">BINGO</span>：<b>横/縦/斜め(2本)</b>が<b>完全に同色</b>で揃うと、そのラインの石を消去（得点＝消した石数）。</div>
  <div style="margin-top:6px;"><span class="warn">リーチ</span>：あなた（黒）の石が<b>あと1マスでBINGO</b>になるラインは、盤面上で光って表示されます。</div>
  <div style="margin-top:6px;"><span class="warn">パスルール</span>：盤上に<b>空きマスがある</b>のに手番が指せる手が無い場合は <b>相手のターン</b>（自動パス）。</div>
  <div style="margin-top:6px;"><span class="warn">終局</span>：双方とも指せる手が無い（=両者の合法手が0）状態になったら<b>ゲームオーバー</b>。ただしその瞬間に⚡が残っていれば<b>稲妻で続行</b>できます。</div>
  <div style="margin-top:6px;"><span class="warn">稲妻</span>：敵の駒をランダムに<b>5個</b>破壊 → 破壊した<b>5箇所すべて</b>に<b>自駒を5個</b>再配置（<b>手番は消費しない / 自駒破壊コストなし</b> / 初期所持：黒1・白1）。</div>
  <div style="margin-top:6px;">操作：タップ＝着手 / <kbd>⚡稲妻</kbd>＝アイテム発動 / <kbd>リセット</kbd>＝初期化</div>
</div>

<script>
(() => {
  // ===== DOM =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const turnPill = document.getElementById('turnPill');
  const scorePill = document.getElementById('scorePill');
  const diffPill = document.getElementById('diffPill');
  const itemPill = document.getElementById('itemPill');
  const titlePill = document.getElementById('titlePill');

  const modeSel = document.getElementById('modeSel');
  const themeSel = document.getElementById('themeSel');
  const lightningBtn = document.getElementById('lightningBtn');
  const resetBtn = document.getElementById('resetBtn');

  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovBody = document.getElementById('ovBody');
  const ovPrimary = document.getElementById('ovPrimary');
  const ovSecondary = document.getElementById('ovSecondary');

  const toastEl = document.getElementById('toast');

  const rules = document.getElementById('rules');
  const rulesBtn = document.getElementById('rulesBtn');
  const rulesClose = document.getElementById('rulesClose');

  // ===== themes =====
  const THEMES = {
    neon: {
      name: 'ネオン',
      pageBg: '#060a10',
      boardBg: '#0a1320',
      boardFrame: '#0f1822',
      grid: 'rgba(170,220,255,0.16)',
      legal: 'rgba(90,255,210,0.22)',
      last: 'rgba(255,210,120,0.65)',
      flashHue: 200,
      reach: 'rgba(120,255,235,0.38)',
      reachCell: 'rgba(120,255,235,0.62)',
      bingo: 'rgba(255,255,255,0.92)',
      bingoGlow: 'rgba(120,255,235,0.75)',
      stones: {
        1: { main:'#18e6ff', edge:'#0aa3b3', hi:'rgba(255,255,255,0.80)', glow:'rgba(24,230,255,0.80)' },
        2: { main:'#ff2bd6', edge:'#b80e98', hi:'rgba(255,255,255,0.72)', glow:'rgba(255,43,214,0.75)' },
      }
    },
    classic: {
      name: 'クラシック',
      pageBg: '#0b0f14',
      boardBg: '#0a5c2e',
      boardFrame: '#0b2a17',
      grid: 'rgba(0,0,0,0.22)',
      legal: 'rgba(255,255,255,0.18)',
      last: 'rgba(255,210,120,0.6)',
      flashHue: 45,
      reach: 'rgba(255,235,180,0.30)',
      reachCell: 'rgba(255,235,180,0.55)',
      bingo: 'rgba(255,235,180,0.95)',
      bingoGlow: 'rgba(0,0,0,0)',
      stones: {
        1: { main:'#0b0b0b', edge:'#000000', hi:'rgba(80,80,80,0.60)', glow:'rgba(0,0,0,0)' },
        2: { main:'#f2f2f2', edge:'#cfcfcf', hi:'rgba(255,255,255,0.92)', glow:'rgba(0,0,0,0)' },
      }
    }
  };

  // ===== canvas fit =====
  function fitCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', () => { fitCanvas(); syncHud(); });

  // ===== constants =====
  const N = 8;
  const EMPTY = 0;
  const B = 1; // player (human)
  const W = 2; // CPU
  const dirs8 = [
    [1,0],[-1,0],[0,1],[0,-1],
    [1,1],[1,-1],[-1,1],[-1,-1]
  ];

  // ===== state =====
  const state = {
    board: Array.from({length:N}, () => Array(N).fill(EMPTY)),
    turn: B,
    scoreB: 0,
    scoreW: 0,
    itemB: 1,
    itemW: 1,
    mode: 'cpu',
    theme: 'neon',
    legal: new Set(),
    lastMove: null,
    anims: [],
    shake: 0,
    busy: false,
    gameOver: false,
    winner: null,
    flash: 0,
    flashHue: 200,
    awaitingChoice: false,
    toastTimer: null,
    reach: { defs: [], empties: [] },
  };

  // ===== safety (avoid stuck busy) =====
  window.addEventListener('error', (e)=>{
    console.error('window error', e.error || e.message);
    state.busy = false;
    state.awaitingChoice = false;
    syncHud();
  });
  window.addEventListener('unhandledrejection', (e)=>{
    console.error('unhandled rejection', e.reason);
    state.busy = false;
    state.awaitingChoice = false;
    syncHud();
  });

  // ===== helpers =====
  const opponent = (p) => (p===B ? W : B);
  const inb = (x,y) => (x>=0 && x<N && y>=0 && y<N);
  const get = (x,y) => state.board[y][x];
  const set = (x,y,v) => { state.board[y][x] = v; };
  const key = (x,y) => `${x},${y}`;
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function randInt(n){ return Math.floor(Math.random()*n); }
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = randInt(i+1);
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  function countEmpty(){
    let n=0;
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) if(get(x,y)===EMPTY) n++;
    return n;
  }

  function toast(msg, ms=1600){
    clearTimeout(state.toastTimer);
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    state.toastTimer = setTimeout(()=>toastEl.classList.remove('show'), ms);
  }

  function showOverlay(title, body, primaryText='OK', onPrimary=null, secondaryText=null, onSecondary=null){
    ovTitle.textContent = title;
    ovBody.textContent = body;
    ovPrimary.textContent = primaryText;
    ovSecondary.style.display = secondaryText ? 'inline-block' : 'none';
    if(secondaryText) ovSecondary.textContent = secondaryText;

    ovPrimary.onclick = () => { hideOverlay(); onPrimary && onPrimary(); };
    ovSecondary.onclick = () => { hideOverlay(); onSecondary && onSecondary(); };

    overlay.style.display = 'flex';
  }
  function hideOverlay(){ overlay.style.display = 'none'; }

  // ===== othello flips =====
  function collectFlips(x,y,player){
    if(!inb(x,y) || get(x,y)!==EMPTY) return [];
    const opp = opponent(player);
    const flips=[];

    for(const [dx,dy] of dirs8){
      let cx=x+dx, cy=y+dy;
      const line=[];
      while(inb(cx,cy)){
        const s=get(cx,cy);
        if(s===opp){ line.push([cx,cy]); cx+=dx; cy+=dy; continue; }
        if(s===player){ if(line.length) flips.push(...line); }
        break;
      }
    }
    return flips;
  }

  function computeLegalFor(player){
    const legal = new Set();
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        if(get(x,y)!==EMPTY) continue;
        if(collectFlips(x,y,player).length>0) legal.add(key(x,y));
      }
    }
    return legal;
  }

  function computeLegal(){ state.legal = computeLegalFor(state.turn); }

  function isBothNoMoves(){
    if(state.legal.size!==0) return false;
    const oppLegal = computeLegalFor(opponent(state.turn));
    return oppLegal.size===0;
  }

  function countItems(player){ return player===B ? state.itemB : state.itemW; }
  function decItem(player){
    if(player===B) state.itemB = Math.max(0, state.itemB-1);
    else state.itemW = Math.max(0, state.itemW-1);
  }

  function updateTurnAndPassIfNeeded(){
    const empties = countEmpty();
    if(state.legal.size!==0) return;
    if(empties>0){
      state.turn = opponent(state.turn);
      computeLegal();
      recomputeReach();
    }
  }

  // ===== reach =====
  function computeReachFor(player){
    const enemy = opponent(player);
    const defs=[];
    const empties=[];
    const defSet = new Set();
    const emptySet = new Set();
    const legal = computeLegalFor(player);

    const addReach = (def, empty) => {
      const ek = key(empty.x, empty.y);
      if(!legal.has(ek)) return;
      const dk = `${def.kind}:${def.idx}`;
      if(!defSet.has(dk)){
        defs.push(def);
        defSet.add(dk);
      }
      if(!emptySet.has(ek)){
        empties.push(empty);
        emptySet.add(ek);
      }
    };

    for(let y=0;y<N;y++){
      let pc=0, ec=0, bad=false; let ex=-1;
      for(let x=0;x<N;x++){
        const s=get(x,y);
        if(s===enemy){ bad=true; break; }
        if(s===player) pc++;
        else if(s===EMPTY){ ec++; ex=x; }
      }
      if(!bad && pc===N-1 && ec===1){
        addReach({kind:'row', idx:y}, {x:ex, y, kind:'row', idx:y});
      }
    }

    for(let x=0;x<N;x++){
      let pc=0, ec=0, bad=false; let ey=-1;
      for(let y=0;y<N;y++){
        const s=get(x,y);
        if(s===enemy){ bad=true; break; }
        if(s===player) pc++;
        else if(s===EMPTY){ ec++; ey=y; }
      }
      if(!bad && pc===N-1 && ec===1){
        addReach({kind:'col', idx:x}, {x, y:ey, kind:'col', idx:x});
      }
    }

    {
      let pc=0, ec=0, bad=false; let ei=-1;
      for(let i=0;i<N;i++){
        const s=get(i,i);
        if(s===enemy){ bad=true; break; }
        if(s===player) pc++;
        else if(s===EMPTY){ ec++; ei=i; }
      }
      if(!bad && pc===N-1 && ec===1){
        addReach({kind:'diag', idx:0}, {x:ei, y:ei, kind:'diag', idx:0});
      }
    }

    {
      let pc=0, ec=0, bad=false; let ei=-1;
      for(let i=0;i<N;i++){
        const x=N-1-i, y=i;
        const s=get(x,y);
        if(s===enemy){ bad=true; break; }
        if(s===player) pc++;
        else if(s===EMPTY){ ec++; ei=i; }
      }
      if(!bad && pc===N-1 && ec===1){
        addReach({kind:'diag', idx:1}, {x:N-1-ei, y:ei, kind:'diag', idx:1});
      }
    }

    // also detect bingo that will form after a legal move (enemy stones flipped)
    const lineFullAfterMove = (cells, moveSet) => {
      for(const [x,y] of cells){
        const k = key(x,y);
        const s = get(x,y);
        if(s===player || moveSet.has(k)) continue;
        return false;
      }
      return true;
    };

    for(const kk of legal){
      const [mx,my] = kk.split(',').map(Number);
      const flips = collectFlips(mx,my,player);
      const moveSet = new Set([kk]);
      for(const [fx,fy] of flips) moveSet.add(key(fx,fy));

      const checks = [
        {kind:'row', idx:my, cells: Array.from({length:N}, (_,i)=>[i,my])},
        {kind:'col', idx:mx, cells: Array.from({length:N}, (_,i)=>[mx,i])},
      ];
      if(mx===my) checks.push({kind:'diag', idx:0, cells: Array.from({length:N}, (_,i)=>[i,i])});
      if(mx===N-1-my) checks.push({kind:'diag', idx:1, cells: Array.from({length:N}, (_,i)=>[N-1-i,i])});

      for(const c of checks){
        if(lineFullAfterMove(c.cells, moveSet)){
          addReach({kind:c.kind, idx:c.idx}, {x:mx, y:my, kind:c.kind, idx:c.idx});
        }
      }
    }

    return {defs, empties};
  }

  function recomputeReach(){
    if(state.gameOver){
      state.reach = {defs: [], empties: []};
      return;
    }
    state.reach = computeReachFor(state.turn);
  }

  // ===== deletion rules =====
  function findDeletions(){
    const cells = new Set();
    const defs = [];
    let lines = 0;

    for(let y=0;y<N;y++){
      const s = get(0,y);
      if(s===EMPTY) continue;
      let ok=true;
      for(let x=1;x<N;x++) if(get(x,y)!==s){ ok=false; break; }
      if(ok){
        lines++; defs.push({kind:'row', idx:y});
        for(let x=0;x<N;x++) cells.add(key(x,y));
      }
    }

    for(let x=0;x<N;x++){
      const s = get(x,0);
      if(s===EMPTY) continue;
      let ok=true;
      for(let y=1;y<N;y++) if(get(x,y)!==s){ ok=false; break; }
      if(ok){
        lines++; defs.push({kind:'col', idx:x});
        for(let y=0;y<N;y++) cells.add(key(x,y));
      }
    }

    {
      const s = get(0,0);
      if(s!==EMPTY){
        let ok=true;
        for(let i=1;i<N;i++) if(get(i,i)!==s){ ok=false; break; }
        if(ok){
          lines++; defs.push({kind:'diag', idx:0});
          for(let i=0;i<N;i++) cells.add(key(i,i));
        }
      }
    }

    {
      const s = get(N-1,0);
      if(s!==EMPTY){
        let ok=true;
        for(let i=1;i<N;i++) if(get(N-1-i,i)!==s){ ok=false; break; }
        if(ok){
          lines++; defs.push({kind:'diag', idx:1});
          for(let i=0;i<N;i++) cells.add(key(N-1-i,i));
        }
      }
    }

    return {cells, lines, defs};
  }

  function addScore(player, n){
    if(n<=0) return;
    if(player===B) state.scoreB += n;
    else state.scoreW += n;
  }

  function comboGain(cellCount, lines){
    const mul = 1 + 0.5*Math.max(0, lines-1);
    return Math.max(0, Math.round(cellCount * mul));
  }

  // ===== FX =====
  function addFlash(amount){
    const th = THEMES[state.theme] || THEMES.neon;
    state.flashHue = th.flashHue;
    state.flash = Math.min(1, state.flash + amount);
  }

  function boltPath(from, to, seed){
    const pts=[];
    const steps=10;
    const rnd=(i)=>{
      const x = Math.sin(seed*999 + i*123.45)*43758.5453;
      return x - Math.floor(x);
    };
    for(let i=0;i<=steps;i++){
      const t=i/steps;
      const x = from.x + (to.x-from.x)*t;
      const y = from.y + (to.y-from.y)*t;
      const dx=to.x-from.x, dy=to.y-from.y;
      const len=Math.hypot(dx,dy)||1;
      const nx=-dy/len, ny=dx/len;
      const j=(rnd(i)-0.5) * (0.7*(1-Math.abs(t-0.5)*1.7));
      pts.push({x:x+nx*j, y:y+ny*j});
    }
    return pts;
  }

  function spawnLightningAnim(destroyed){
    addFlash(0.62);
    state.shake = Math.min(22, state.shake + 10);

    const origin = {x:N/2, y:-0.9};
    const targets = [...destroyed].slice(0, 10);
    for(const [tx,ty] of targets){
      const to = {x:tx+0.5, y:ty+0.5};
      state.anims.push({type:'bolt', t:0, pts: boltPath(origin, to, Math.random()*9999)});

      const pCount = 18 + Math.floor(Math.random()*14);
      for(let i=0;i<pCount;i++){
        const ang = Math.random()*Math.PI*2;
        const sp = 2.2 + Math.random()*6.4;
        state.anims.push({type:'spark', t:0, x:tx+0.5, y:ty+0.5, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, life:0.45+Math.random()*0.28});
      }
    }
  }

  function bingoLabel(lines){
    if(lines>=3) return 'TRIPLE BINGO!';
    if(lines===2) return 'DOUBLE BINGO!';
    return 'BINGO!';
  }

  function spawnDeleteAnim(cells, scoreValue, lines, lineDefs){
    for(const [x,y] of cells){
      const s = get(x,y);
      state.anims.push({type:'pop', x, y, t:0, s, seed:Math.random()*9999});
    }

    for(const d of (lineDefs || [])){
      state.anims.push({type:'line', t:0, kind:d.kind, idx:d.idx});
    }

    if((lines||0) > 0){
      let sx=0, sy=0;
      for(const [x,y] of cells){ sx+=x; sy+=y; }
      const cx = sx/Math.max(1,cells.length);
      const cy = sy/Math.max(1,cells.length);
      state.anims.push({type:'bingo', t:0, x:cx, y:cy, lines});
    }

    if(cells.length>0 && scoreValue>0){
      let sx=0, sy=0;
      for(const [x,y] of cells){ sx+=x; sy+=y; }
      const cx=sx/cells.length, cy=sy/cells.length;
      state.anims.push({type:'score', x:cx, y:cy, t:0, value:scoreValue, lines});

      const pCount = Math.min(140, 22 + cells.length*3 + ((lines||1)-1)*14);
      for(let i=0;i<pCount;i++){
        const base = cells[Math.floor(Math.random()*cells.length)];
        const ang = Math.random()*Math.PI*2;
        const sp = 1.1 + Math.random()*4.8;
        state.anims.push({type:'spark', t:0, x:base[0]+0.5, y:base[1]+0.5, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, life:0.52+Math.random()*0.32});
      }
    }

    state.shake = Math.min(16, state.shake + Math.min(10, cells.length*0.22 + ((lines||1)-1)*2.7));
    addFlash(Math.min(0.6, 0.18 + cells.length*0.008 + ((lines||1)-1)*0.10));
  }

  async function resolveAfterChange(scoringPlayer){
    for(let chain=0; chain<8; chain++){
      const delInfo = findDeletions();
      if(delInfo.lines===0) break;

      const cells=[];
      for(const k of delInfo.cells){
        const [x,y]=k.split(',').map(Number);
        cells.push([x,y]);
      }

      const gain = comboGain(cells.length, delInfo.lines);
      spawnDeleteAnim(cells, gain, delInfo.lines, delInfo.defs);
      await sleep(130);

      for(const [x,y] of cells) set(x,y,EMPTY);
      addScore(scoringPlayer, gain);
      recomputeReach();
      syncHud();
      await sleep(120);
    }
  }

  // ===== end / lightning choice =====
  function declareGameOver(){
    state.gameOver = true;
    let winner='D';
    if(state.scoreB > state.scoreW) winner='B';
    else if(state.scoreW > state.scoreB) winner='W';
    state.winner = winner;

    const winText = winner==='D' ? '引き分け' : (winner==='B' ? 'あなた(黒)の勝ち' : 'CPU(白)の勝ち');
    showOverlay('ゲームオーバー：'+winText, `双方とも合法手がありません。得点 黒:${state.scoreB} / 白:${state.scoreW}`,
      'もう一度', () => { resetGame(); },
      '閉じる', () => {}
    );
  }

  function checkEndOrHandleLightningChoice(){
    if(!isBothNoMoves()) return false;

    const cur = state.turn;
    const opp = opponent(cur);
    const curHas = countItems(cur)>0;
    const oppHas = countItems(opp)>0;

    if(curHas){
      if(state.mode==='cpu' && cur===W){
        toast('CPUが⚡稲妻を使った！');
        setTimeout(()=>useLightning(), 120);
        return true;
      }

      state.awaitingChoice = true;
      syncHud();
      showOverlay(
        '手がありません',
        '双方とも合法手がありません。⚡稲妻を使って続行しますか？',
        '稲妻を使う',
        () => { state.awaitingChoice=false; useLightning(); },
        'ゲームオーバー',
        () => { state.awaitingChoice=false; declareGameOver(); }
      );
      return true;
    }

    if(oppHas){
      state.turn = opp;
      computeLegal();
      recomputeReach();
      syncHud();
      if(state.mode==='cpu' && state.turn===W){
        toast('CPUが⚡稲妻を使った！');
        setTimeout(()=>useLightning(), 120);
        return true;
      }
      return true;
    }

    declareGameOver();
    return true;
  }

  // ===== reset =====
  function resetBoardKeepScoreAndItems(){
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) set(x,y,EMPTY);
    set(3,3,W); set(4,4,W);
    set(4,3,B); set(3,4,B);

    state.turn = B;
    state.lastMove = null;
    state.anims.length = 0;
    state.shake = 0;
    state.busy = false;
    state.gameOver = false;
    state.winner = null;
    state.awaitingChoice = false;

    computeLegal();
    updateTurnAndPassIfNeeded();
    recomputeReach();
    syncHud();
  }

  function resetGame(){
    state.scoreB = 0;
    state.scoreW = 0;
    state.itemB = 1;
    state.itemW = 1;
    resetBoardKeepScoreAndItems();
  }

  // ===== lightning (no self-cost, destroy 5 enemies) =====
  function ensureEnemiesForLightning(player, desiredCount){
    const enemy = opponent(player);
    const enemyCells=[];
    const emptyCells=[];

    for(let y=0;y<N;y++) for(let x=0;x<N;x++){
      const cell = get(x,y);
      if(cell===enemy) enemyCells.push([x,y]);
      else if(cell===EMPTY) emptyCells.push([x,y]);
    }

    if(enemyCells.length===0 && emptyCells.length===0) return null;

    shuffle(emptyCells);
    while(enemyCells.length < desiredCount && emptyCells.length>0){
      const pos = emptyCells.pop();
      set(pos[0], pos[1], enemy);
      enemyCells.push(pos);
    }

    return enemyCells;
  }

  async function useLightning(){
    if(state.busy || state.gameOver) return;
    if(state.awaitingChoice) return;

    const player = state.turn;
    computeLegal();

    if(!isBothNoMoves()) return;
    if(countItems(player)<=0) return;

    state.busy = true;
    try{
      const enemyCells = ensureEnemiesForLightning(player, 5);
      if(!enemyCells || enemyCells.length===0) return;

      decItem(player);

      shuffle(enemyCells);
      const destroyed = enemyCells.slice(0, Math.min(5, enemyCells.length));
      if(destroyed.length===0) return;

      spawnLightningAnim(destroyed);
      await sleep(110);

      for(const [x,y] of destroyed) set(x,y,EMPTY);
      for(const [x,y] of destroyed) set(x,y,player);

      await resolveAfterChange(player);

      computeLegal();
      updateTurnAndPassIfNeeded();
      recomputeReach();
      syncHud();

      checkEndOrHandleLightningChoice();

      if(state.mode==='cpu' && state.turn===W && !state.gameOver && !state.awaitingChoice){
        if(isBothNoMoves() && countItems(W)>0){
          toast('CPUが⚡稲妻を使った！');
          setTimeout(useLightning, 120);
        } else {
          setTimeout(cpuStep, 220);
        }
      }
    } catch(e){
      console.error('useLightning failed', e);
    } finally {
      state.busy = false;
      syncHud();
    }
  }

  // ===== moves =====
  function placeMove(x,y){
    if(state.busy || state.gameOver || state.awaitingChoice) return;
    if(!inb(x,y)) return;
    const k = key(x,y);
    if(!state.legal.has(k)) return;

    const player = state.turn;
    const flips = collectFlips(x,y,player);

    state.busy = true;
    set(x,y,player);
    for(const [fx,fy] of flips) set(fx,fy,player);
    state.lastMove = {x,y,player,flips:flips.length};

    (async () => {
      try{
        await resolveAfterChange(player);

        state.turn = opponent(state.turn);
        computeLegal();
        updateTurnAndPassIfNeeded();
        recomputeReach();
        syncHud();

        const handled = checkEndOrHandleLightningChoice();
        if(handled) return;

        if(state.mode==='cpu' && state.turn===W){
          setTimeout(cpuStep, 220);
        }
      } finally {
        state.busy = false;
        syncHud();
      }
    })();
  }

  // ===== CPU =====
  function cpuStep(){
    if(state.busy || state.gameOver || state.awaitingChoice) return;
    if(state.turn!==W) return;

    computeLegal();
    updateTurnAndPassIfNeeded();
    if(state.turn!==W) return;

    if(isBothNoMoves()){
      if(countItems(W)>0){
        toast('CPUが⚡稲妻を使った！');
        useLightning();
      } else {
        declareGameOver();
      }
      return;
    }

    if(state.legal.size===0){
      checkEndOrHandleLightningChoice();
      return;
    }

    let best=null;
    for(const kk of state.legal){
      const [mx,my]=kk.split(',').map(Number);
      const flips = collectFlips(mx,my,W);
      const score = evaluateMove(mx,my,flips);
      if(!best || score>best.score) best={x:mx,y:my,score};
    }
    if(best) placeMove(best.x,best.y);
  }

  function evaluateMove(x,y,flips){
    const corners = ((x===0&&y===0)||(x===7&&y===0)||(x===0&&y===7)||(x===7&&y===7)) ? 3.0 : 0;
    const edge = (x===0||x===7||y===0||y===7) ? 0.25 : 0;
    return flips.length*1.0 + corners + edge;
  }

  // ===== UI =====
  function syncHud(){
    const th = THEMES[state.theme] || THEMES.neon;
    document.body.style.background = th.pageBg;

    titlePill.textContent = 'REVINGO';

    turnPill.textContent = `手番: ${state.turn===B?'黒(あなた)':'白(CPU)'}${state.busy?'（処理中）':''}${state.gameOver?'（終了）':''}`;
    scorePill.textContent = `得点 黒:${state.scoreB} / 白:${state.scoreW}`;
    diffPill.textContent = `スコア差(自分-敵): ${state.scoreB - state.scoreW}`;
    itemPill.textContent = `⚡ 黒:${state.itemB} / 白:${state.itemW}`;

    const canUse = !state.busy && !state.gameOver && !state.awaitingChoice && countItems(state.turn)>0 && isBothNoMoves();
    lightningBtn.disabled = !canUse;
  }

  const savedTheme = localStorage.getItem('theme');
  if(savedTheme && THEMES[savedTheme]) state.theme = savedTheme;
  themeSel.value = state.theme;
  modeSel.value = 'cpu';

  themeSel.addEventListener('change', ()=>{
    state.theme = themeSel.value;
    localStorage.setItem('theme', state.theme);
    syncHud();
  });

  modeSel.addEventListener('change', ()=>{
    state.mode = modeSel.value;
    syncHud();
    if(!state.gameOver && state.mode==='cpu' && state.turn===W && !state.awaitingChoice){
      setTimeout(cpuStep, 220);
    }
  });

  lightningBtn.addEventListener('click', ()=> useLightning());
  resetBtn.addEventListener('click', ()=>{ hideOverlay(); resetGame(); });

  rulesBtn.addEventListener('click', ()=> rules.classList.add('show'));
  rulesClose.addEventListener('click', ()=> rules.classList.remove('show'));

  // ===== input mapping =====
  function boardRect(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const size = Math.min(w,h) * 0.94;
    const x = (w - size)/2;
    const y = (h - size)/2;
    return {x,y,size,cell:size/N};
  }

  function pointToCell(mx,my){
    const rect = canvas.getBoundingClientRect();
    const x = mx - rect.left;
    const y = my - rect.top;
    const br = boardRect();
    if(x<br.x || y<br.y || x>=br.x+br.size || y>=br.y+br.size) return null;
    const cx = Math.floor((x - br.x)/br.cell);
    const cy = Math.floor((y - br.y)/br.cell);
    return {cx,cy};
  }

  canvas.addEventListener('pointerup', (e)=>{
    const c = pointToCell(e.clientX, e.clientY);
    if(!c) return;
    placeMove(c.cx, c.cy);
  });

  // ===== render =====
  function easeOutCubic(t){ return 1-Math.pow(1-t,3); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function drawStone(px,py,r,player){
    const th = THEMES[state.theme] || THEMES.neon;
    const c = th.stones[player];
    if(!c) return;

    ctx.fillStyle='rgba(0,0,0,0.28)';
    ctx.beginPath();
    ctx.ellipse(px+r*0.12, py+r*0.16, r*1.05, r*0.92, 0, 0, Math.PI*2);
    ctx.fill();

    if(state.theme==='neon'){
      ctx.save();
      ctx.shadowColor = c.glow;
      ctx.shadowBlur = r*0.9;
    }

    ctx.fillStyle = c.main;
    ctx.beginPath();
    ctx.arc(px,py,r,0,Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = c.edge;
    ctx.lineWidth = Math.max(1, r*0.18);
    ctx.beginPath();
    ctx.arc(px,py,r*0.98,0,Math.PI*2);
    ctx.stroke();

    ctx.fillStyle = c.hi;
    ctx.beginPath();
    ctx.ellipse(px-r*0.35, py-r*0.38, r*0.55, r*0.32, -0.4, 0, Math.PI*2);
    ctx.fill();

    if(state.theme==='neon') ctx.restore();
  }

  function draw(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const th = THEMES[state.theme] || THEMES.neon;

    const sh = state.shake;
    const sx = sh ? (Math.random()*2-1)*sh : 0;
    const sy = sh ? (Math.random()*2-1)*sh : 0;
    state.shake = Math.max(0, state.shake - 0.20);

    state.flash = Math.max(0, state.flash - 0.045);

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = th.pageBg;
    ctx.fillRect(0,0,w,h);

    const br = boardRect();
    const bx = br.x+sx, by=br.y+sy, size=br.size, cs=br.cell;

    ctx.fillStyle = th.boardFrame;
    ctx.beginPath();
    ctx.roundRect(bx-cs*0.18, by-cs*0.18, size+cs*0.36, size+cs*0.36, Math.min(22,size*0.06));
    ctx.fill();

    ctx.fillStyle = th.boardBg;
    ctx.beginPath();
    ctx.roundRect(bx,by,size,size,Math.min(18,size*0.06));
    ctx.fill();

    ctx.lineWidth = 1;
    ctx.strokeStyle = th.grid;
    for(let i=0;i<=N;i++){
      const x=bx+i*cs;
      ctx.beginPath(); ctx.moveTo(x,by); ctx.lineTo(x,by+size); ctx.stroke();
      const y=by+i*cs;
      ctx.beginPath(); ctx.moveTo(bx,y); ctx.lineTo(bx+size,y); ctx.stroke();
    }

    // reach highlight
    {
      const t = performance.now()/1000;
      const pulse = 0.55 + 0.45*Math.sin(t*2.2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.lineCap='round'; ctx.lineJoin='round';
      ctx.strokeStyle = th.reach;
      ctx.lineWidth = Math.max(2, cs*(0.06 + 0.03*pulse));

      for(const d of state.reach.defs){
        ctx.beginPath();
        if(d.kind==='row'){
          const y = by + (d.idx+0.5)*cs;
          ctx.moveTo(bx + cs*0.28, y);
          ctx.lineTo(bx + size - cs*0.28, y);
        } else if(d.kind==='col'){
          const x = bx + (d.idx+0.5)*cs;
          ctx.moveTo(x, by + cs*0.28);
          ctx.lineTo(x, by + size - cs*0.28);
        } else if(d.kind==='diag' && d.idx===0){
          const pad=cs*0.28;
          ctx.moveTo(bx+pad, by+pad);
          ctx.lineTo(bx+size-pad, by+size-pad);
        } else {
          const pad=cs*0.28;
          ctx.moveTo(bx+size-pad, by+pad);
          ctx.lineTo(bx+pad, by+size-pad);
        }
        ctx.stroke();
      }

      ctx.setLineDash([cs*0.18, cs*0.12]);
      ctx.strokeStyle = th.reachCell;
      ctx.lineWidth = Math.max(2, cs*(0.05 + 0.03*pulse));
      for(const e of state.reach.empties){
        const px = bx + e.x*cs;
        const py = by + e.y*cs;
        ctx.beginPath();
        ctx.roundRect(px+cs*0.10, py+cs*0.10, cs*0.80, cs*0.80, cs*0.18);
        ctx.stroke();
      }
      ctx.restore();
    }

    if(!state.gameOver && !state.awaitingChoice){
      ctx.fillStyle = th.legal;
      for(const kk of state.legal){
        const [x,y]=kk.split(',').map(Number);
        const px=bx+x*cs, py=by+y*cs;
        ctx.beginPath();
        ctx.roundRect(px+cs*0.16, py+cs*0.16, cs*0.68, cs*0.68, cs*0.16);
        ctx.fill();
      }
    }

    if(state.lastMove){
      const {x,y}=state.lastMove;
      const px=bx+x*cs, py=by+y*cs;
      ctx.strokeStyle = th.last;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.roundRect(px+cs*0.10, py+cs*0.10, cs*0.80, cs*0.80, cs*0.18);
      ctx.stroke();
    }

    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const s=get(x,y);
        if(s===EMPTY) continue;
        const cx=bx+x*cs+cs/2;
        const cy=by+y*cs+cs/2;
        drawStone(cx,cy,cs*0.40,s);
      }
    }

    for(const a of state.anims) a.t += 1/60;
    state.anims = state.anims.filter(a => {
      if(a.type==='pop') return a.t < 0.55;
      if(a.type==='score') return a.t < 0.9;
      if(a.type==='spark') return a.t < a.life;
      if(a.type==='line') return a.t < 0.52;
      if(a.type==='bolt') return a.t < 0.28;
      if(a.type==='bingo') return a.t < 0.8;
      return a.t < 0.8;
    });

    ctx.save();
    ctx.globalCompositeOperation='lighter';

    for(const a of state.anims){
      if(a.type!=='line') continue;
      const p = easeOutCubic(clamp(a.t/0.52,0,1));
      const alpha = (1-p)*0.95;
      const glow = cs*(0.11 + 0.26*(1-p));
      ctx.lineCap='round'; ctx.lineJoin='round';
      ctx.strokeStyle = `rgba(255,220,150,${alpha})`;
      ctx.lineWidth = Math.max(2, glow);
      ctx.beginPath();
      if(a.kind==='row'){
        const y = by + (a.idx+0.5)*cs;
        const x1 = bx + cs*0.25;
        const x2 = bx + size - cs*0.25;
        const xm = x1 + (x2-x1)*p;
        ctx.moveTo(x1,y); ctx.lineTo(xm,y);
      } else if(a.kind==='col'){
        const x = bx + (a.idx+0.5)*cs;
        const y1 = by + cs*0.25;
        const y2 = by + size - cs*0.25;
        const ym = y1 + (y2-y1)*p;
        ctx.moveTo(x,y1); ctx.lineTo(x,ym);
      } else {
        const pad = cs*0.25;
        if(a.idx===0){
          const x1=bx+pad, y1=by+pad;
          const x2=bx+size-pad, y2=by+size-pad;
          const xm=x1+(x2-x1)*p;
          const ym=y1+(y2-y1)*p;
          ctx.moveTo(x1,y1); ctx.lineTo(xm,ym);
        } else {
          const x1=bx+size-pad, y1=by+pad;
          const x2=bx+pad, y2=by+size-pad;
          const xm=x1+(x2-x1)*p;
          const ym=y1+(y2-y1)*p;
          ctx.moveTo(x1,y1); ctx.lineTo(xm,ym);
        }
      }
      ctx.stroke();
    }

    for(const a of state.anims){
      if(a.type!=='bolt') continue;
      const p = clamp(a.t/0.28,0,1);
      const alpha = (1-p)*0.95;
      const pts=a.pts;
      ctx.strokeStyle = `rgba(200,235,255,${alpha})`;
      ctx.lineWidth = Math.max(2, cs*0.085);
      ctx.beginPath();
      ctx.moveTo(bx + pts[0].x*cs, by + pts[0].y*cs);
      for(let i=1;i<pts.length;i++) ctx.lineTo(bx + pts[i].x*cs, by + pts[i].y*cs);
      ctx.stroke();
      ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
      ctx.lineWidth = Math.max(1, cs*0.03);
      ctx.beginPath();
      ctx.moveTo(bx + pts[0].x*cs, by + pts[0].y*cs);
      for(let i=1;i<pts.length;i++) ctx.lineTo(bx + pts[i].x*cs, by + pts[i].y*cs);
      ctx.stroke();
    }

    for(const a of state.anims){
      if(a.type!=='spark') continue;
      const p = clamp(a.t/a.life,0,1);
      const alpha = (1-p)*0.85;
      const x = bx + (a.x + a.vx*p*0.18)*cs;
      const y = by + (a.y + a.vy*p*0.18)*cs;
      ctx.fillStyle = `rgba(255,220,140,${alpha})`;
      ctx.beginPath();
      ctx.arc(x,y,Math.max(1.2, cs*0.03*(1-p)),0,Math.PI*2);
      ctx.fill();
    }

    // BINGO stamp
    for(const a of state.anims){
      if(a.type!=='bingo') continue;
      const t = clamp(a.t/0.8, 0, 1);
      const bump = t < 0.55 ? (0.7 + (1.15-0.7)*easeOutCubic(t/0.55)) : (1.15 + (1.0-1.15)*easeOutCubic((t-0.55)/0.45));
      const alpha = t < 0.15 ? (t/0.15) : (1 - Math.max(0,(t-0.15)/0.85));
      const cx = bx + a.x*cs + cs/2;
      const cy = by + a.y*cs + cs/2;
      const text = bingoLabel(a.lines||1);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(bump, bump);

      if(state.theme==='neon'){
        ctx.shadowColor = th.bingoGlow;
        ctx.shadowBlur = cs*0.7;
      }

      ctx.font = `900 ${Math.max(20, cs*0.82)}px system-ui`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillStyle = th.bingo;
      ctx.lineWidth = Math.max(3, cs*0.10);
      ctx.strokeStyle = `rgba(0,0,0,${0.55*alpha})`;
      ctx.strokeText(text, 0, 0);
      ctx.globalAlpha = alpha;
      ctx.fillText(text, 0, 0);
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    ctx.restore();

    for(const a of state.anims){
      if(a.type==='pop'){
        const p = easeOutCubic(clamp(a.t/0.55,0,1));
        const alpha = 1 - p;
        const cx = bx + a.x*cs + cs/2;
        const cy = by + a.y*cs + cs/2;
        const r = cs*(0.46 + 0.30*p);
        ctx.strokeStyle = `rgba(255,255,255,${0.18*alpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx,cy,r,0,Math.PI*2);
        ctx.stroke();
      } else if(a.type==='score'){
        const p = easeOutCubic(clamp(a.t/0.9,0,1));
        const alpha = 1 - p;
        const cx = bx + a.x*cs + cs/2;
        const cy = by + a.y*cs + cs/2 - cs*(0.8*p);
        if(state.theme==='neon'){
          ctx.font = `bold ${Math.max(18, cs*0.7)}px system-ui`;
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillStyle = `rgba(255,255,255,${alpha})`;
          ctx.fillText(`+${a.value}`, cx, cy);
          if((a.lines||1) > 1){
            ctx.font = `bold ${Math.max(14, cs*0.45)}px system-ui`;
            ctx.fillStyle = `hsla(${state.flashHue},100%,70%,${alpha})`;
            ctx.fillText(`COMBO x${a.lines}`, cx, cy + cs*0.55);
          }
        } else {
          ctx.font = `bold ${Math.max(16, cs*0.6)}px system-ui`;
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillStyle = `rgba(255,220,140,${alpha})`;
          ctx.fillText(`+${a.value}`, cx, cy);
          if((a.lines||1) > 1){
            ctx.font = `bold ${Math.max(12, cs*0.38)}px system-ui`;
            ctx.fillStyle = `rgba(255,235,180,${alpha})`;
            ctx.fillText(`COMBO x${a.lines}`, cx, cy + Math.max(14, cs*0.42));
          }
        }
      }
    }

    if(state.flash>0){
      const a = state.flash;
      ctx.save();
      ctx.globalCompositeOperation='screen';
      ctx.fillStyle = `hsla(${state.flashHue}, 95%, 60%, ${0.18*a})`;
      ctx.fillRect(0,0,w,h);
      ctx.restore();
    }

    requestAnimationFrame(draw);
  }

  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  // ===== tests =====
  function assert(cond, msg){ if(!cond) throw new Error('TEST FAILED: '+msg); }
  function clearBoard(){ for(let y=0;y<N;y++) for(let x=0;x<N;x++) set(x,y,EMPTY); }
  function countStones(){
    let c=0;
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) if(get(x,y)!==EMPTY) c++;
    return c;
  }
  function countBy(player){
    let c=0;
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) if(get(x,y)===player) c++;
    return c;
  }

  function runTests(){
    resetGame();
    assert(countStones()===4, 'reset should place exactly 4 stones');
    assert(get(3,3)===W && get(4,4)===W && get(4,3)===B && get(3,4)===B, 'initial 4 stones should match standard othello');

    assert(state.turn===B, 'turn should be black after reset');
    assert(state.legal.size===4, 'initial legal moves for black should be 4');

    clearBoard();
    for(let x=0;x<N;x++) set(x,0,B);
    let delInfo = findDeletions();
    assert(delInfo.lines===1, 'full row should count as 1 line');
    assert(delInfo.cells.size===8, 'full row should delete 8 stones');

    clearBoard();
    for(let x=0;x<N;x++) set(x,0,B);
    for(let y=0;y<N;y++) set(0,y,B);
    delInfo = findDeletions();
    assert(delInfo.lines===2, 'row+col should count as 2 lines');
    assert(delInfo.cells.size===15, 'row+col union should be 15 cells');

    clearBoard();
    set(0,0,B);
    set(1,0,W);
    state.turn = W;
    computeLegal();
    assert(state.legal.size===0, 'white should have no legal moves in this setup');
    updateTurnAndPassIfNeeded();
    assert(state.turn===B, 'turn should pass to black');
    assert(state.legal.size>0, 'black should have at least one legal move after pass');

    clearBoard();
    for(let x=0;x<N;x++) set(x,2,B);
    set(5,2,EMPTY);
    set(5,3,W);
    set(5,4,B);
    const reach = computeReachFor(B);
    assert(reach.defs.some(d=>d.kind==='row' && d.idx===2), 'reach should detect a row reach');
    assert(reach.empties.some(e=>e.x===5 && e.y===2), 'reach should include the empty cell');
    clearBoard();
    for(let x=0;x<N;x++) set(x,2,B);
    set(5,2,EMPTY);
    const reachNoLegal = computeReachFor(B);
    assert(reachNoLegal.defs.length===0 && reachNoLegal.empties.length===0,
      'reach should not highlight cells where the move is illegal');
    state.turn = W;
    recomputeReach();
    assert(state.reach.defs.length===0 && state.reach.empties.length===0, 'reach highlights should hide during CPU turn');
    state.turn = B;
    recomputeReach();
    assert(state.reach.defs.some(d=>d.kind==='row' && d.idx===2), 'reach highlights should reappear on player turn');

    clearBoard();
    for(let y=0;y<N;y++) set(3,y,B);
    set(3,1,EMPTY);
    set(3,2,W);
    const reachWithFlip = computeReachFor(B);
    assert(reachWithFlip.empties.some(e=>e.x===3 && e.y===1 && e.kind==='col' && e.idx===3),
      'reach should count a column that becomes bingo after flipping an enemy stone');

    clearBoard();
    set(3,3,B); set(4,4,B);
    const injected = ensureEnemiesForLightning(B, 5);
    assert(!!injected, 'enemy=0 lightning should inject enemies if empties exist');
    assert(injected.length===5, 'lightning prep should create 5 enemy stones when possible');
    assert(countBy(W)===5, 'after injection there should be exactly 5 enemy stones');

    console.log('%cAll tests passed','color:#8fdd98');
  }

  // ===== boot =====
  fitCanvas();
  resetGame();
  runTests();
  resetGame();
  recomputeReach();
  syncHud();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
